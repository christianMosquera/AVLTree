        -:    0:Source:avl_tree.h
        -:    0:Graph:avl_tree_tests.gcno
        -:    0:Data:avl_tree_tests.gcda
        -:    0:Runs:1
        -:    1:#ifndef AVL_TREE_H
        -:    2:#define AVL_TREE_H
        -:    3:
        -:    4:#include <cstddef>
        -:    5:#include <iostream>
        -:    6:
        -:    7:
        -:    8:/*****************************************************
        -:    9: **
        -:   10: ** File:    avl_tree.h
        -:   11: ** Project: CSCE 221 Lab 4 Spring 2022
        -:   12: ** Author:  Christian Mosquera
        -:   13: ** Date:    03/21/22
        -:   14: ** Section: 510
        -:   15: ** Email:   cwbo.1701@tamu.edu
        -:   16: ** 
        -:   17: ** This file contains all the functions for avl tree
        -:   18: ** and their implementaions. There are public functions
        -:   19: ** that the user can call and their are private functions
        -:   20: ** that help the public functions perform their actions.
        -:   21: **
        -:   22: *****************************************************/
        -:   23:
        -:   24:template <typename Comparable>
        -:   25:class AVLTree {
        -:   26:
        -:   27:public:
        -:   28:
        -:   29:    AVLTree();
        -:   30:    AVLTree(const AVLTree& other);
        -:   31:    ~AVLTree();
        -:   32:    AVLTree& operator=(const AVLTree& other);
        -:   33:    bool contains(const Comparable& value) const;
        -:   34:    void insert(const Comparable& value);
        -:   35:    void remove(const Comparable& value);
        -:   36:    const Comparable& find_min() const;
        -:   37:    const Comparable& find_max() const;
        -:   38:    void print_tree(std::ostream& os=std::cout) const;
        -:   39:    bool is_empty() const;
        -:   40:    void make_empty();
        -:   41:
        -:   42:private:
        -:   43:
        -:   44:    struct AVLNode {
        -:   45:        int height;
        -:   46:        AVLNode* left;
        -:   47:        AVLNode* right;
        -:   48:        Comparable value;
        -:   49:        AVLNode() : height(0), left(nullptr), right(nullptr), value() {}
       79:   50:        AVLNode(Comparable value) : height(0), left(nullptr), right(nullptr), value(value) {}
        -:   51:    };
        -:   52:
        -:   53:    AVLNode* root;
        -:   54:
        -:   55:    void preorderInsert(AVLNode* current);
        -:   56:    void insertRecurse(const Comparable& value, AVLNode* &currNode);
        -:   57:    void singleLeftShift(AVLNode* &node);
        -:   58:    int findHeight(AVLNode* node) const;
        -:   59:    int max(int a, int b);
        -:   60:    void balance(AVLNode* &node);
        -:   61:    void singleRightShift(AVLNode* &node);
        -:   62:    void removeRecurse(const Comparable& value, AVLNode* &current);
        -:   63:    Comparable& recurse_find_min(AVLNode* node) const;
        -:   64:    Comparable& recurse_find_max(AVLNode* node) const;
        -:   65:    void printRecurse(AVLNode* node, int count, std::ostream& os) const;
        -:   66:    void emptyRecurse(AVLNode* &node);
        -:   67:    bool containRecurse(AVLNode* node, const Comparable& value) const;
        -:   68:
        -:   69:    
        -:   70:};
        -:   71:
        -:   72:
        -:   73:
        -:   74://---------------------------------------
        -:   75:// Name: Defalut Constructor
        -:   76://---------------------------------------
        -:   77:template <typename Comparable>
        4:   78:AVLTree<Comparable>::AVLTree() : root(nullptr) {}
        -:   79:
        -:   80:
        -:   81:
        -:   82://---------------------------------------
        -:   83:// Name: Copy Constructor
        -:   84:// PreCondition:  other tree is given
        -:   85:// PostCondition: A deep copied second tree
        -:   86://---------------------------------------
        -:   87:template <typename Comparable>
        1:   88:AVLTree<Comparable>::AVLTree(const AVLTree& other) : root(nullptr) {
        -:   89:
        -:   90:    // preorder traversal to copy
        1:   91:    if (other.root != nullptr) {
        1:   92:        this->preorderInsert(other.root);
        -:   93:    }
        -:   94:
        1:   95:}
        -:   96:
        -:   97:
        -:   98:
        -:   99://---------------------------------------
        -:  100:// Name: Destructor
        -:  101://---------------------------------------
        -:  102:template <typename Comparable>
        5:  103:AVLTree<Comparable>::~AVLTree() {
        -:  104:
        5:  105:    make_empty();
        -:  106:    
        5:  107:}
        -:  108:
        -:  109:
        -:  110:
        -:  111://---------------------------------------
        -:  112:// Name: Copy assignment
        -:  113:// PreCondition:  other is given
        -:  114:// PostCondition: A deep copied tree
        -:  115://---------------------------------------
        -:  116:template <typename Comparable>
        3:  117:AVLTree<Comparable>& AVLTree<Comparable>::operator=(const AVLTree& other) {
        -:  118:
        -:  119:    // If this is the same as other
        3:  120:    if (this == &other) {
        1:  121:        return *this;
        -:  122:    }
        -:  123:
        -:  124:    // make this empty first
        2:  125:    this->make_empty();
        -:  126:
        -:  127:    // if other is empty
        2:  128:    if (other.root == nullptr) {
        1:  129:        this->root = nullptr;
        1:  130:        return *this;
        -:  131:    }
        -:  132:
        -:  133:    // if other is non empty
        1:  134:    this->preorderInsert(other.root);
        1:  135:    return *this;
        -:  136:
        -:  137:}
        -:  138:
        -:  139:
        -:  140:
        -:  141://---------------------------------------
        -:  142:// Name: contains
        -:  143:// PreCondition: Value is comparable
        -:  144:// PostCondition: Returns if value is in binary tree
        -:  145://---------------------------------------
        -:  146:template <typename Comparable>
       13:  147:bool AVLTree<Comparable>::contains(const Comparable& value) const {
        -:  148:
       13:  149:    return containRecurse(root, value);
        -:  150:
        -:  151:}
        -:  152:
        -:  153:
        -:  154:
        -:  155://---------------------------------------
        -:  156:// Name: containRecurse
        -:  157:// PreCondition:  Node is not nullptr and value is comparable
        -:  158:// PostCondition: Returns if value is in binary tree
        -:  159://---------------------------------------
        -:  160:template <typename Comparable>
       60:  161:bool AVLTree<Comparable>::containRecurse(AVLNode* node, const Comparable& value) const {
        -:  162:
        -:  163:    // Base case for nullptr
       60:  164:    if (node) {
        -:  165:
        -:  166:        // Found value
       51:  167:        if (node->value == value) {
        4:  168:            return true;
        -:  169:        }
        -:  170:
        -:  171:        // Traverse left
       47:  172:        else if (value < node->value) {
       24:  173:            return containRecurse(node->left, value);
        -:  174:        }
        -:  175:        
        -:  176:        // Traverse right
       23:  177:        else if (value > node->value) {
       23:  178:            return containRecurse(node->right, value);
        -:  179:        }
        -:  180:
        -:  181:    }
        -:  182:    
        -:  183:    // Once it traverses to a null
        9:  184:    return false;
        -:  185:
        -:  186:}
        -:  187:
        -:  188:
        -:  189:
        -:  190://---------------------------------------
        -:  191:// Name: insert
        -:  192:// PreCondition:  Value is comparable
        -:  193:// PostCondition: Node inserted into the binary tree
        -:  194://---------------------------------------
        -:  195:template <typename Comparable>
       80:  196:void AVLTree<Comparable>::insert(const Comparable& value) {
        -:  197:
       80:  198:    insertRecurse(value, this->root);
        -:  199:
       80:  200:}
        -:  201:
        -:  202:
        -:  203:
        -:  204://---------------------------------------
        -:  205:// Name: insertRecurse
        -:  206:// PreCondition:  Value is comparable
        -:  207:// PostCondition: Node inserted into the binary tree
        -:  208://---------------------------------------
        -:  209:template <typename Comparable>
      289:  210:void AVLTree<Comparable>::insertRecurse(const Comparable& value, AVLNode* &currNode) {
        -:  211:
        -:  212:    // base case
      289:  213:    if (currNode == nullptr) {
       79:  214:        currNode = new AVLNode(value);
        -:  215:    }
        -:  216:
        -:  217:    // left sub tree
      210:  218:    else if (value < currNode->value) {
      101:  219:        insertRecurse(value, currNode->left);
        -:  220:    }
        -:  221:
        -:  222:    // right sub tree
      109:  223:    else if (value > currNode->value) {
      108:  224:        insertRecurse(value, currNode->right);   
        -:  225:    }
        -:  226:
        -:  227:    // Balance the tree
      289:  228:    balance(currNode);
        -:  229:
      289:  230:}
        -:  231:
        -:  232:
        -:  233:
        -:  234://---------------------------------------
        -:  235:// Name: remove
        -:  236:// PreCondition:  Value is comparable
        -:  237:// PostCondition: Removes the value from the tree
        -:  238://---------------------------------------
        -:  239:template <typename Comparable>
        8:  240:void AVLTree<Comparable>::remove(const Comparable& value) {
        -:  241:
        8:  242:    removeRecurse(value, this->root);
        -:  243:
        8:  244:}
        -:  245:
        -:  246:
        -:  247:
        -:  248://---------------------------------------
        -:  249:// Name: removeRecurse
        -:  250:// PreCondition:  Value is comparable
        -:  251:// PostCondition: Removes the value from the tree
        -:  252://---------------------------------------
        -:  253:template <typename Comparable>
       27:  254:void AVLTree<Comparable>::removeRecurse(const Comparable& value, AVLNode* &current) {
        -:  255:
        -:  256:    // find value
       27:  257:    if (!current) {
        1:  258:        return;
        -:  259:    }
        -:  260:
       26:  261:    if (value == current->value) {
        -:  262:
        -:  263:        // case 1: leaf node
        9:  264:        if (current->left == nullptr && current->right == nullptr) {
        4:  265:            delete current;
        4:  266:            current = nullptr;
        -:  267:        }
        -:  268:
        -:  269:        // case 2: right sub tree and left sub tree
        5:  270:        else if (current->left && current->right) {
        -:  271:
        -:  272:            // Find max in left sub tree
        2:  273:            Comparable& minRight = recurse_find_min(current->right);
        2:  274:            current->value = minRight;
        2:  275:            removeRecurse(minRight, current->right);
        -:  276:
        -:  277:        }
        -:  278:
        -:  279:        // case 3: right sub tree or left sub tree
        3:  280:        else if (current->right || current->left) {
        -:  281:
        3:  282:            AVLNode* temp = current;
        3:  283:            if (current->right) {
        2:  284:                current = current->right;
        2:  285:                delete temp;
        -:  286:            }
        -:  287:            else {
        1:  288:                current = current->left;
        1:  289:                delete temp;
        -:  290:            }
        -:  291:        }
        -:  292:    }
        -:  293:
       17:  294:    else if (value < current->value) {
        4:  295:        removeRecurse(value, current->left);
        -:  296:    }
        -:  297:
        -:  298:    else {
       13:  299:        removeRecurse(value, current->right);
        -:  300:    }
        -:  301:    
        -:  302:    // At the end of inserting, make sure tree balanced
       26:  303:    balance(current);
        -:  304:    
        -:  305:}
        -:  306:
        -:  307:
        -:  308:
        -:  309://---------------------------------------
        -:  310:// Name: find_min
        -:  311:// PreCondition:  Binary tree exists
        -:  312:// PostCondition: Returns the minimum value
        -:  313://---------------------------------------
        -:  314:template <typename Comparable>
        5:  315:const Comparable& AVLTree<Comparable>::find_min() const {
        -:  316:
        5:  317:    return recurse_find_min(root);
        -:  318:
        -:  319:}
        -:  320:
        -:  321:
        -:  322:
        -:  323://---------------------------------------
        -:  324:// Name: recurse_find_min
        -:  325:// PreCondition:  Binary tree exists
        -:  326:// PostCondition: Returns the minimum value
        -:  327://---------------------------------------
        -:  328:template <typename Comparable>
       18:  329:Comparable& AVLTree<Comparable>::recurse_find_min(AVLNode* node) const{
        -:  330:
        -:  331:    // Throws error if the tree is empty
       18:  332:    if (!node) {
        1:  333:        throw std::invalid_argument("Tree is empty, no minimum value.");
        -:  334:    }
        -:  335:
        -:  336:    // Traverse all the way to the left
       17:  337:    if (node->left == nullptr) {
        6:  338:        return node->value;
        -:  339:    }
       11:  340:    return recurse_find_min(node->left);
        -:  341:
        -:  342:}
        -:  343:
        -:  344:
        -:  345:
        -:  346://---------------------------------------
        -:  347:// Name: find_max
        -:  348:// PreCondition:  Binary tree exists
        -:  349:// PostCondition: Returns maximum value
        -:  350://---------------------------------------
        -:  351:template <typename Comparable>
        5:  352:const Comparable& AVLTree<Comparable>::find_max() const {
        -:  353:    
        5:  354:    return recurse_find_max(this->root);
        -:  355:
        -:  356:}
        -:  357:
        -:  358:
        -:  359:
        -:  360://---------------------------------------
        -:  361:// Name: recurse_find_max
        -:  362:// PreCondition:  Binary tree exists
        -:  363:// PostCondition: Returns maximum value
        -:  364://---------------------------------------
        -:  365:template <typename Comparable>
       13:  366:Comparable& AVLTree<Comparable>::recurse_find_max(AVLNode* node) const {
        -:  367:
        -:  368:    // Throws error if the tree is empty
       13:  369:    if (!node) {
        1:  370:        throw std::invalid_argument("Tree is empty, no maximum value.");
        -:  371:    }
        -:  372:
        -:  373:    // Traverse all the way to the right
       12:  374:    if (node->right == nullptr) {
        4:  375:        return node->value;
        -:  376:    }
        -:  377:
        8:  378:    return recurse_find_max(node->right);
        -:  379:
        -:  380:}
        -:  381:
        -:  382:
        -:  383:
        -:  384://---------------------------------------
        -:  385:// Name: print_tree
        -:  386:// PreCondition:  Tree exists
        -:  387:// PostCondition: Outputs to the os stream that is specified
        -:  388://---------------------------------------
        -:  389:template <typename Comparable>
       65:  390:void AVLTree<Comparable>::print_tree(std::ostream& os) const {
        -:  391:
        -:  392:    // If tree is empty
       65:  393:    if (this->root == nullptr) {
        2:  394:        os << "<empty>" << std::endl;
        -:  395:    }
        -:  396:
        -:  397:    // non empty tree
       65:  398:    int count = -1;
       65:  399:    printRecurse(root, count, os);
       65:  400:}
        -:  401:
        -:  402:
        -:  403:
        -:  404://---------------------------------------
        -:  405:// Name: printRecurse
        -:  406:// PreCondition:  Tree exists
        -:  407:// PostCondition: Outputs to the os stream
        -:  408://---------------------------------------
        -:  409:template <typename Comparable>
     1017:  410:void AVLTree<Comparable>::printRecurse(AVLNode* node, int count, std::ostream& os) const {
        -:  411:
        -:  412:    // check for nullptr
     1017:  413:    if (node) {
        -:  414:
        -:  415:        // Keep track of depth
      476:  416:        count++;
        -:  417:
      476:  418:        printRecurse(node->right, count, os);
        -:  419:
        -:  420:        // Determine amount of spacing
      476:  421:        if (node != root) {
     2097:  422:            for (int i = 0; i < count*2; i++) {
     1684:  423:                os << " ";
        -:  424:            }
        -:  425:        }
        -:  426:
      476:  427:        os << node->value << std::endl;
      476:  428:        printRecurse(node->left, count, os);
        -:  429:
        -:  430:    }
     1017:  431:}
        -:  432:
        -:  433:
        -:  434:
        -:  435://---------------------------------------
        -:  436:// Name: is_empty
        -:  437:// PreCondition:  N/A
        -:  438:// PostCondition: Returns true if root is nullptr
        -:  439://---------------------------------------
        -:  440:template <typename Comparable>
        5:  441:bool AVLTree<Comparable>::is_empty() const {
        -:  442:
        5:  443:    return (root == nullptr);
        -:  444:
        -:  445:}
        -:  446:
        -:  447:
        -:  448:
        -:  449://---------------------------------------
        -:  450:// Name: make_empty
        -:  451:// PreCondition:  Tree exists
        -:  452:// PostCondition: All nodes from tree are removed
        -:  453://---------------------------------------
        -:  454:template <typename Comparable>
        9:  455:void AVLTree<Comparable>::make_empty() {
        -:  456:
        9:  457:    emptyRecurse(root);
        -:  458:
        9:  459:}
        -:  460:
        -:  461://---------------------------------------
        -:  462:// Name: emptyRecurse
        -:  463:// PreCondition:  Tree exists
        -:  464:// PostCondition: All nodes from tree are removed
        -:  465://---------------------------------------
        -:  466:template <typename Comparable>
      153:  467:void AVLTree<Comparable>::emptyRecurse(AVLNode* &node) {
        -:  468:
        -:  469:    // Base case for nullptr
      153:  470:    if (node) {
        -:  471:        
       72:  472:        emptyRecurse(node->left);
       72:  473:        emptyRecurse(node->right);
       72:  474:        delete node;
        -:  475:
        -:  476:    }
        -:  477:
        -:  478:    // make node nullptr
      153:  479:    node = nullptr;
      153:  480:}
        -:  481:
        -:  482:
        -:  483:
        -:  484://---------------------------------------
        -:  485:// Name: findHeight
        -:  486:// PreCondition:  node is given
        -:  487:// PostCondition: Returns the height of the node
        -:  488://---------------------------------------
        -:  489:template <typename Comparable>
     1558:  490:int AVLTree<Comparable>::findHeight(AVLNode* node) const{
        -:  491:    
        -:  492:    // null nodes are height -1, otherwise return stored height
     1558:  493:    return !node? -1 : node->height;
        -:  494:
        -:  495:}
        -:  496:
        -:  497:
        -:  498:
        -:  499://---------------------------------------
        -:  500:// Name: max
        -:  501:// PreCondition:  a and b are given
        -:  502:// PostCondition: Returns the greater of the two
        -:  503://---------------------------------------
        -:  504:template <typename Comparable>
      427:  505:int AVLTree<Comparable>::max(int a, int b) {
        -:  506:
        -:  507:    // returns max value
      427:  508:    return a > b ? a : b;
        -:  509:
        -:  510:}
        -:  511:
        -:  512:
        -:  513:
        -:  514://---------------------------------------
        -:  515:// Name: preorderInsert
        -:  516:// PreCondition:  Current is not nullptr
        -:  517:// PostCondition: A fully inserted binary search tree
        -:  518://---------------------------------------
        -:  519:template <typename Comparable>
       58:  520:void AVLTree<Comparable>::preorderInsert(AVLNode* current) {
        -:  521:
        -:  522:    // base case if null
       58:  523:    if (current) {
       28:  524:        this->insert(current->value);
       28:  525:        this->preorderInsert(current->left);
       28:  526:        this->preorderInsert(current->right);
        -:  527:    }
        -:  528:
       58:  529:    return;
        -:  530:
        -:  531:}
        -:  532:
        -:  533:
        -:  534:
        -:  535:template <typename Comparable>
      315:  536:void AVLTree<Comparable>::balance(AVLNode* &node) {
        -:  537:    
      315:  538:    if (!node) {
        4:  539:        return;
        -:  540:    }
        -:  541:    
        -:  542:    // Balance factor
      311:  543:    int factor = findHeight(node->left) - findHeight(node->right);
        -:  544:
        -:  545:    // Right skewed
      311:  546:    if (factor < -1) {
        -:  547:
        -:  548:        // Single shift left right skewed
       20:  549:        if (findHeight(node->right->right) >= findHeight(node->right->left)) {
       12:  550:            singleLeftShift(node);
        -:  551:        }
        -:  552:
        -:  553:        // left skewed
        -:  554:        else {
        8:  555:            singleRightShift(node->right);
        8:  556:            singleLeftShift(node);
        -:  557:        }
        -:  558:    }
        -:  559:
        -:  560:    // Left skewed
      291:  561:    else if (factor > 1) {
       21:  562:        if (findHeight(node->left->left) >= findHeight(node->left->right)) {
       12:  563:            singleRightShift(node);
        -:  564:        }
        -:  565:
        -:  566:        else {
        9:  567:            singleLeftShift(node->left);
        9:  568:            singleRightShift(node);
        -:  569:        } 
        -:  570:    }
        -:  571:
        -:  572:    // Update the height of the node
      311:  573:    node->height = max(findHeight(node->left), findHeight(node->right)) + 1;
        -:  574:    
        -:  575:}
        -:  576:
        -:  577:
        -:  578:
        -:  579:template <typename Comparable>
       29:  580:void AVLTree<Comparable>::singleLeftShift(AVLNode* &node) {
        -:  581:
       29:  582:    AVLNode* nodeRight = node->right;
        -:  583:
        -:  584:    // Shift left
       29:  585:    node->right = nodeRight->left;
       29:  586:    nodeRight->left = node;
        -:  587:
        -:  588:    // Update heights
       29:  589:    node->height = max(findHeight(node->left), findHeight(node->right)) + 1;
       29:  590:    nodeRight->height = max(findHeight(nodeRight->left), findHeight(nodeRight->right)) + 1;
        -:  591:
        -:  592:    // Switch spots
       29:  593:    node = nodeRight;
        -:  594:
       29:  595:}
        -:  596:
        -:  597:
        -:  598:
        -:  599:template <typename Comparable>
       29:  600:void AVLTree<Comparable>::singleRightShift(AVLNode* &node) {
        -:  601:
       29:  602:    AVLNode* nodeLeft = node->left;
        -:  603:
        -:  604:    // Shift left
       29:  605:    node->left = nodeLeft->right;
       29:  606:    nodeLeft->right = node;
        -:  607:
        -:  608:    // Update heights
       29:  609:    node->height = max(findHeight(node->left), findHeight(node->right)) + 1;
       29:  610:    nodeLeft->height = max(findHeight(nodeLeft->left), findHeight(nodeLeft->right)) + 1;
        -:  611:
        -:  612:    // Switch spots
       29:  613:    node = nodeLeft;
        -:  614:
       29:  615:}
        -:  616:
        -:  617:#endif
